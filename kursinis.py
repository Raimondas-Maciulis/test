# -*- coding: utf-8 -*-
"""Kursinis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RlVvBtsoeqCzcT6SwfUTevr2VmGb7q0Z
"""

import json
import unittest
from abc import ABC, abstractmethod
from typing import List, Optional
from datetime import datetime, timedelta


class LibraryCatalog:
    __instance = None

    def __new__(cls):
        if cls.__instance is None:
            cls.__instance = super(LibraryCatalog, cls).__new__(cls)
            cls.__instance.books = []
        return cls.__instance

    def add_book(self, book):
        self.books.append(book)

    def get_books(self):
        return self.books


class LibraryStorage:
    BOOKS_FILE = 'books.json'
    MEMBERS_FILE = 'members.json'
    LIBRARIANS_FILE = 'librarians.json'

    @staticmethod
    def save_books(books: List['Book']):
        with open(LibraryStorage.BOOKS_FILE, 'w') as f:
            json.dump([{"title": b.title, "author": b.author.name} for b in books], f, indent=4)

    @staticmethod
    def load_books() -> List['Book']:
        try:
            with open(LibraryStorage.BOOKS_FILE, 'r') as f:
                data = json.load(f)
                return [Book(item['title'], Author(item['author'])) for item in data]
        except FileNotFoundError:
            return []

    @staticmethod
    def save_members(members: List['Member']):
        with open(LibraryStorage.MEMBERS_FILE, 'w') as f:
            json.dump([{
                "name": m.name,
                "id": m._Member__member_id,
                "fines": m.fines
            } for m in members], f, indent=4)

    @staticmethod
    def load_members() -> List['Member']:
        try:
            with open(LibraryStorage.MEMBERS_FILE, 'r') as f:
                data = json.load(f)
                return [Member(item['name'], item['id']) for item in data]
        except FileNotFoundError:
            return []

    @staticmethod
    def save_librarians(librarians: List['Librarian']):
        with open(LibraryStorage.LIBRARIANS_FILE, 'w') as f:
            json.dump([{
                "name": l.name,
                "id": l._Librarian__employee_id
            } for l in librarians], f, indent=4)

    @staticmethod
    def load_librarians() -> List['Librarian']:
        try:
            with open(LibraryStorage.LIBRARIANS_FILE, 'r') as f:
                data = json.load(f)
                return [Librarian(item['name'], item['id']) for item in data]
        except FileNotFoundError:
            return []


class Person(ABC):
    def __init__(self, name: str):
        self.name = name

    @abstractmethod
    def get_role(self):
        pass


class Librarian(Person):
    def __init__(self, name: str, employee_id: int):
        super().__init__(name)
        self.__employee_id = employee_id

    def get_role(self):
        return "Librarian"

    def add_book_to_catalog(self, book):
        catalog = LibraryCatalog()
        catalog.add_book(book)
        print(f"Book '{book.title}' added to catalog by {self.name}.")


class Member(Person):
    def __init__(self, name: str, member_id: int):
        super().__init__(name)
        self.__member_id = member_id
        self.borrowed_books = []
        self.reserved_books = []
        self.fines = 0.0

    def get_role(self):
        return "Member"


class Author:
    def __init__(self, name: str):
        self.name = name


class Book:
    def __init__(self, title: str, author: Author):
        self.title = title
        self.author = author
        self.__borrower: Optional[Member] = None
        self.__due_date: Optional[datetime] = None
        self.__reservations: List[Member] = []
        self.__extended = False

    def get_due_date(self):
        return self.__due_date

    def get_borrower(self):
        return self.__borrower

    def get_reservations(self):
        return self.__reservations

    def is_available(self):
        return self.__borrower is None

    def mark_borrowed(self, member: Member):
        self.__borrower = member
        self.__due_date = datetime.now() + timedelta(days=14)
        self.__extended = False

    def mark_returned(self):
        overdue_days = 0
        if self.__due_date and datetime.now() > self.__due_date:
            overdue_days = (datetime.now() - self.__due_date).days
        self.__borrower = None
        self.__due_date = None
        self.__extended = False
        return overdue_days

    def reserve(self, member: Member):
        if member not in self.__reservations:
            self.__reservations.append(member)

    def extend_borrow_period(self):
        if self.__borrower and self.__due_date and not self.__extended:
            self.__due_date += timedelta(days=30)
            self.__extended = True
            return True
        return False



class PersonFactory:
    @staticmethod
    def create_person(role: str, name: str, id: int) -> Person:
        if role.lower() == "librarian":
            return Librarian(name, id)
        elif role.lower() == "member":
            return Member(name, id)
        else:
            raise ValueError("Invalid role")

people: List[Person] = [
    PersonFactory.create_person("librarian", "Alice", 1),
    PersonFactory.create_person("member", "Bob", 101)
]

for person in people:
    print(f"{person.name} is a {person.get_role()}.")


class LibraryBranch:
    def __init__(self, name: str):
        self.name = name
        self.members: List[Member] = []
        self.staff: List[Librarian] = []

    def add_member(self, member: Member):
        self.members.append(member)
        print(f"{member.name} has been added to {self.name} branch.")

    def add_staff(self, librarian: Librarian):
        self.staff.append(librarian)
        print(f"{librarian.name} has been added to {self.name} branch.")

    def borrow_book(self, member: Member, book: Book):
     if book.is_available():
        book.mark_borrowed(member)
        member.borrowed_books.append(book)
        print(f"{member.name} borrowed '{book.title}' from {self.name} branch.")
     else:
        print(f"'{book.title}' is currently not available.")

    def return_book(self, member: Member, book: Book):
        if book in member.borrowed_books:
            overdue_days = book.mark_returned()
            member.borrowed_books.remove(book)
            if overdue_days > 0:
                fine = overdue_days * 0.5
                member.fines += fine
                print(f"{member.name} returned '{book.title}' late. Fine: ${fine:.2f}")
            else:
                print(f"{member.name} returned '{book.title}' on time.")
            if book.get_reservations():
                next_member = book.get_reservations().pop(0)
                self.borrow_book(next_member, book)


    def reserve_book(self, member: Member, book: Book):
        if book.is_available():
            print(f"No need to reserve '{book.title}', it is available.")
        else:
            book.reserve(member)
            member.reserved_books.append(book)
            print(f"{member.name} reserved '{book.title}'.")

    def extend_due_date(self, member: Member, book: Book):
        if book in member.borrowed_books:
            extended = book.extend_borrow_period()
            if extended:
                print(f"{member.name} extended due date for '{book.title}' by one month.")
            else:
                print(f"Could not extend due date for '{book.title}'.")

class TestLibrarySystem(unittest.TestCase):

    def test_book_availability(self):
        author = Author("Test Author")
        book = Book("Test Book", author)

        self.assertTrue(book.is_available())


    def test_borrow_book(self):
        author = Author("Test Author")
        book = Book("Test Book", author)
        member = Member("Test Member", 1)
        branch = LibraryBranch("Main")
        branch.add_member(member)
        branch.borrow_book(member, book)

        self.assertFalse(book.is_available())
        self.assertIn(book, member.borrowed_books)


    def test_return_book(self):
        author = Author("Test Author")
        book = Book("Test Book", author)
        member = Member("Test Member", 1)
        branch = LibraryBranch("Main")
        branch.add_member(member)
        branch.borrow_book(member, book)
        branch.return_book(member, book)

        self.assertTrue(book.is_available())
        self.assertNotIn(book, member.borrowed_books)


    def test_reservation(self):
        author = Author("Test Author")
        book = Book("Test Book", author)
        member1 = Member("Member1", 1)
        member2 = Member("Member2", 2)
        branch = LibraryBranch("Central")
        branch.add_member(member1)
        branch.add_member(member2)

        branch.borrow_book(member1, book)
        branch.reserve_book(member2, book)

        self.assertIn(member2, book.get_reservations())
        self.assertIn(book, member2.reserved_books)


    def test_extend_due_date(self):
        author = Author("Test Author")
        book = Book("Test Book", author)
        member = Member("Test Member", 1)
        branch = LibraryBranch("Central")
        branch.add_member(member)
        branch.borrow_book(member, book)

        original_due_date = book.get_due_date()

        branch.extend_due_date(member, book)

        self.assertGreater(book.get_due_date(), original_due_date)


    def test_file_io(self):
        author = Author("IO Author")
        book = Book("IO Book", author)

        LibraryStorage.save_books([book])
        loaded_books = LibraryStorage.load_books()

        self.assertEqual(len(loaded_books), 1)
        self.assertEqual(loaded_books[0].title, "IO Book")
        self.assertEqual(loaded_books[0].author.name, "IO Author")


if __name__ == "__main__":
    unittest.main(argv=['first-arg-is-ignored'], exit=False)